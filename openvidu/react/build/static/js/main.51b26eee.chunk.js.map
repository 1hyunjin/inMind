{"version":3,"sources":["OvVideo.js","UserVideoComponent.js","App.js","registerServiceWorker.js","index.js"],"names":["OpenViduVideoComponent","Component","constructor","props","super","this","videoRef","React","createRef","componentDidUpdate","streamManager","addVideoElement","current","componentDidMount","render","_jsx","autoPlay","ref","UserVideoComponent","getNicknameTag","JSON","parse","stream","connection","data","clientData","children","undefined","_jsxs","className","App","state","mySessionId","myUserName","Math","floor","random","session","mainStreamManager","publisher","subscribers","joinSession","bind","leaveSession","switchCamera","handleChangeSessionId","handleChangeUserName","handleMainVideoStream","onbeforeunload","window","addEventListener","componentWillUnmount","removeEventListener","event","e","setState","target","value","deleteSubscriber","index","indexOf","splice","OV","OpenVidu","initSession","mySession","on","subscriber","subscribe","push","exception","console","warn","getToken","then","token","connect","async","initPublisherAsync","audioSource","videoSource","publishAudio","publishVideo","resolution","frameRate","insertMode","mirror","publish","videoDevices","getDevices","filter","device","kind","currentVideoDeviceId","getMediaStream","getVideoTracks","getSettings","deviceId","currentVideoDevice","find","catch","error","log","code","message","disconnect","length","newVideoDevice","newPublisher","initPublisher","unpublish","id","src","alt","onSubmit","type","onChange","required","name","onClick","map","sub","i","sessionId","createSession","createToken","response","axios","post","customSessionId","headers","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","controller","ReactDOM","document","getElementById","URL","process","origin","concat","fetch","status","get","ready","unregister","reload","checkValidServiceWorker","registerServiceWorker"],"mappings":"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","file":"static/js/main.51b26eee.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\nexport default class OpenViduVideoComponent extends Component {\n\n    constructor(props) {\n        super(props);\n        this.videoRef = React.createRef();\n    }\n\n    componentDidUpdate(props) {\n        if (props && !!this.videoRef) {\n            this.props.streamManager.addVideoElement(this.videoRef.current);\n        }\n    }\n\n    componentDidMount() {\n        if (this.props && !!this.videoRef) {\n            this.props.streamManager.addVideoElement(this.videoRef.current);\n        }\n    }\n\n    render() {\n        return <video autoPlay={true} ref={this.videoRef} />;\n    }\n\n}\n","import React, { Component } from 'react';\nimport OpenViduVideoComponent from './OvVideo';\nimport './UserVideo.css';\n\nexport default class UserVideoComponent extends Component {\n\n    getNicknameTag() {\n        // Gets the nickName of the user\n        return JSON.parse(this.props.streamManager.stream.connection.data).clientData;\n    }\n\n    render() {\n        return (\n            <div>\n                {this.props.streamManager !== undefined ? (\n                    <div className=\"streamcomponent\">\n                        <OpenViduVideoComponent streamManager={this.props.streamManager} />\n                        <div><p>{this.getNicknameTag()}</p></div>\n                    </div>\n                ) : null}\n            </div>\n        );\n    }\n}\n","import { OpenVidu } from 'openvidu-browser';\n\nimport axios from 'axios';\nimport React, { Component } from 'react';\nimport './App.css';\nimport UserVideoComponent from './UserVideoComponent';\n\n// const APPLICATION_SERVER_URL = process.env.NODE_ENV === 'production' ? '' : 'https://demos.openvidu.io/';\nconst APPLICATION_SERVER_URL = process.env.NODE_ENV === 'production' ? '' : 'https://b301.xyz/';\n\nclass App extends Component {\n    constructor(props) {\n        super(props);\n\n        // These properties are in the state's component in order to re-render the HTML whenever their values change\n        this.state = {\n            mySessionId: 'SessionA',\n            myUserName: 'Participant' + Math.floor(Math.random() * 100),\n            session: undefined,\n            mainStreamManager: undefined,  // Main video of the page. Will be the 'publisher' or one of the 'subscribers'\n            publisher: undefined,\n            subscribers: [],\n        };\n\n        this.joinSession = this.joinSession.bind(this);\n        this.leaveSession = this.leaveSession.bind(this);\n        this.switchCamera = this.switchCamera.bind(this);\n        this.handleChangeSessionId = this.handleChangeSessionId.bind(this);\n        this.handleChangeUserName = this.handleChangeUserName.bind(this);\n        this.handleMainVideoStream = this.handleMainVideoStream.bind(this);\n        this.onbeforeunload = this.onbeforeunload.bind(this);\n    }\n\n    componentDidMount() {\n        window.addEventListener('beforeunload', this.onbeforeunload);\n    }\n\n    componentWillUnmount() {\n        window.removeEventListener('beforeunload', this.onbeforeunload);\n    }\n\n    onbeforeunload(event) {\n        this.leaveSession();\n    }\n\n    handleChangeSessionId(e) {\n        this.setState({\n            mySessionId: e.target.value,\n        });\n    }\n\n    handleChangeUserName(e) {\n        this.setState({\n            myUserName: e.target.value,\n        });\n    }\n\n    handleMainVideoStream(stream) {\n        if (this.state.mainStreamManager !== stream) {\n            this.setState({\n                mainStreamManager: stream\n            });\n        }\n    }\n\n    deleteSubscriber(streamManager) {\n        let subscribers = this.state.subscribers;\n        let index = subscribers.indexOf(streamManager, 0);\n        if (index > -1) {\n            subscribers.splice(index, 1);\n            this.setState({\n                subscribers: subscribers,\n            });\n        }\n    }\n\n    joinSession() {\n        // --- 1) Get an OpenVidu object ---\n\n        this.OV = new OpenVidu();\n\n        // --- 2) Init a session ---\n\n        this.setState(\n            {\n                session: this.OV.initSession(),\n            },\n            () => {\n                var mySession = this.state.session;\n\n                // --- 3) Specify the actions when events take place in the session ---\n\n                // On every new Stream received...\n                mySession.on('streamCreated', (event) => {\n                    // Subscribe to the Stream to receive it. Second parameter is undefined\n                    // so OpenVidu doesn't create an HTML video by its own\n                    var subscriber = mySession.subscribe(event.stream, undefined);\n                    var subscribers = this.state.subscribers;\n                    subscribers.push(subscriber);\n\n                    // Update the state with the new subscribers\n                    this.setState({\n                        subscribers: subscribers,\n                    });\n                });\n\n                // On every Stream destroyed...\n                mySession.on('streamDestroyed', (event) => {\n\n                    // Remove the stream from 'subscribers' array\n                    this.deleteSubscriber(event.stream.streamManager);\n                });\n\n                // On every asynchronous exception...\n                mySession.on('exception', (exception) => {\n                    console.warn(exception);\n                });\n\n                // --- 4) Connect to the session with a valid user token ---\n\n                // Get a token from the OpenVidu deployment\n                this.getToken().then((token) => {\n                    // First param is the token got from the OpenVidu deployment. Second param can be retrieved by every user on event\n                    // 'streamCreated' (property Stream.connection.data), and will be appended to DOM as the user's nickname\n                    mySession.connect(token, { clientData: this.state.myUserName })\n                        .then(async () => {\n\n                            // --- 5) Get your own camera stream ---\n\n                            // Init a publisher passing undefined as targetElement (we don't want OpenVidu to insert a video\n                            // element: we will manage it on our own) and with the desired properties\n                            let publisher = await this.OV.initPublisherAsync(undefined, {\n                                audioSource: undefined, // The source of audio. If undefined default microphone\n                                videoSource: undefined, // The source of video. If undefined default webcam\n                                publishAudio: true, // Whether you want to start publishing with your audio unmuted or not\n                                publishVideo: true, // Whether you want to start publishing with your video enabled or not\n                                resolution: '640x480', // The resolution of your video\n                                frameRate: 30, // The frame rate of your video\n                                insertMode: 'APPEND', // How the video is inserted in the target element 'video-container'\n                                mirror: false, // Whether to mirror your local video or not\n                            });\n\n                            // --- 6) Publish your stream ---\n\n                            mySession.publish(publisher);\n\n                            // Obtain the current video device in use\n                            var devices = await this.OV.getDevices();\n                            var videoDevices = devices.filter(device => device.kind === 'videoinput');\n                            var currentVideoDeviceId = publisher.stream.getMediaStream().getVideoTracks()[0].getSettings().deviceId;\n                            var currentVideoDevice = videoDevices.find(device => device.deviceId === currentVideoDeviceId);\n\n                            // Set the main video in the page to display our webcam and store our Publisher\n                            this.setState({\n                                currentVideoDevice: currentVideoDevice,\n                                mainStreamManager: publisher,\n                                publisher: publisher,\n                            });\n                        })\n                        .catch((error) => {\n                            console.log('There was an error connecting to the session:', error.code, error.message);\n                        });\n                });\n            },\n        );\n    }\n\n    leaveSession() {\n\n        // --- 7) Leave the session by calling 'disconnect' method over the Session object ---\n\n        const mySession = this.state.session;\n\n        if (mySession) {\n            mySession.disconnect();\n        }\n\n        // Empty all properties...\n        this.OV = null;\n        this.setState({\n            session: undefined,\n            subscribers: [],\n            mySessionId: 'SessionA',\n            myUserName: 'Participant' + Math.floor(Math.random() * 100),\n            mainStreamManager: undefined,\n            publisher: undefined\n        });\n    }\n\n    async switchCamera() {\n        try {\n            const devices = await this.OV.getDevices()\n            var videoDevices = devices.filter(device => device.kind === 'videoinput');\n\n            if (videoDevices && videoDevices.length > 1) {\n\n                var newVideoDevice = videoDevices.filter(device => device.deviceId !== this.state.currentVideoDevice.deviceId)\n\n                if (newVideoDevice.length > 0) {\n                    // Creating a new publisher with specific videoSource\n                    // In mobile devices the default and first camera is the front one\n                    var newPublisher = this.OV.initPublisher(undefined, {\n                        videoSource: newVideoDevice[0].deviceId,\n                        publishAudio: true,\n                        publishVideo: true,\n                        mirror: true\n                    });\n\n                    //newPublisher.once(\"accessAllowed\", () => {\n                    await this.state.session.unpublish(this.state.mainStreamManager)\n\n                    await this.state.session.publish(newPublisher)\n                    this.setState({\n                        currentVideoDevice: newVideoDevice[0],\n                        mainStreamManager: newPublisher,\n                        publisher: newPublisher,\n                    });\n                }\n            }\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    render() {\n        const mySessionId = this.state.mySessionId;\n        const myUserName = this.state.myUserName;\n\n        return (\n            <div className=\"container\">\n                {this.state.session === undefined ? (\n                    <div id=\"join\">\n                        <div id=\"img-div\">\n                            <img src=\"resources/images/openvidu_grey_bg_transp_cropped.png\" alt=\"OpenVidu logo\" />\n                        </div>\n                        <div id=\"join-dialog\" className=\"jumbotron vertical-center\">\n                            <h1> Join a video session </h1>\n                            <form className=\"form-group\" onSubmit={this.joinSession}>\n                                <p>\n                                    <label>Participant: </label>\n                                    <input\n                                        className=\"form-control\"\n                                        type=\"text\"\n                                        id=\"userName\"\n                                        value={myUserName}\n                                        onChange={this.handleChangeUserName}\n                                        required\n                                    />\n                                </p>\n                                <p>\n                                    <label> Session: </label>\n                                    <input\n                                        className=\"form-control\"\n                                        type=\"text\"\n                                        id=\"sessionId\"\n                                        value={mySessionId}\n                                        onChange={this.handleChangeSessionId}\n                                        required\n                                    />\n                                </p>\n                                <p className=\"text-center\">\n                                    <input className=\"btn btn-lg btn-success\" name=\"commit\" type=\"submit\" value=\"JOIN\" />\n                                </p>\n                            </form>\n                        </div>\n                    </div>\n                ) : null}\n\n                {this.state.session !== undefined ? (\n                    <div id=\"session\">\n                        <div id=\"session-header\">\n                            <h1 id=\"session-title\">{mySessionId}</h1>\n                            <input\n                                className=\"btn btn-large btn-danger\"\n                                type=\"button\"\n                                id=\"buttonLeaveSession\"\n                                onClick={this.leaveSession}\n                                value=\"Leave session\"\n                            />\n                            <input\n                                className=\"btn btn-large btn-success\"\n                                type=\"button\"\n                                id=\"buttonSwitchCamera\"\n                                onClick={this.switchCamera}\n                                value=\"Switch Camera\"\n                            />\n                        </div>\n\n                        {this.state.mainStreamManager !== undefined ? (\n                            <div id=\"main-video\" className=\"col-md-6\">\n                                <UserVideoComponent streamManager={this.state.mainStreamManager} />\n\n                            </div>\n                        ) : null}\n                        <div id=\"video-container\" className=\"col-md-6\">\n                            {this.state.publisher !== undefined ? (\n                                <div className=\"stream-container col-md-6 col-xs-6\" onClick={() => this.handleMainVideoStream(this.state.publisher)}>\n                                    <UserVideoComponent\n                                        streamManager={this.state.publisher} />\n                                </div>\n                            ) : null}\n                            {this.state.subscribers.map((sub, i) => (\n                                <div key={sub.id} className=\"stream-container col-md-6 col-xs-6\" onClick={() => this.handleMainVideoStream(sub)}>\n                                    <span>{sub.id}</span>\n                                    <UserVideoComponent streamManager={sub} />\n                                </div>\n                            ))}\n                        </div>\n                    </div>\n                ) : null}\n            </div>\n        );\n    }\n\n\n    /**\n     * --------------------------------------------\n     * GETTING A TOKEN FROM YOUR APPLICATION SERVER\n     * --------------------------------------------\n     * The methods below request the creation of a Session and a Token to\n     * your application server. This keeps your OpenVidu deployment secure.\n     *\n     * In this sample code, there is no user control at all. Anybody could\n     * access your application server endpoints! In a real production\n     * environment, your application server must identify the user to allow\n     * access to the endpoints.\n     *\n     * Visit https://docs.openvidu.io/en/stable/application-server to learn\n     * more about the integration of OpenVidu in your application server.\n     */\n    async getToken() {\n        const sessionId = await this.createSession(this.state.mySessionId);\n        return await this.createToken(sessionId);\n    }\n\n    async createSession(sessionId) {\n        const response = await axios.post(APPLICATION_SERVER_URL + 'openvidu/api/sessions', { customSessionId: sessionId }, {\n            headers: { 'Content-Type': 'application/json', 'Authorization': 'Basic T1BFTlZJRFVBUFA6c3NhZnk=',},\n        });\n\tconsole.log(sessionId);\n\tconsole.log(response.data);\n        return response.data; // The sessionId\n    }\n\n    async createToken(sessionId) {\n\tconsole.log(sessionId);\n        const response = await axios.post(APPLICATION_SERVER_URL + 'openvidu/api/sessions/' + sessionId.sessionId + '/connection', {}, {\n            headers: { 'Content-Type': 'application/json', 'Authorization': 'Basic T1BFTlZJRFVBUFA6c3NhZnk=', },\n        });\n\tconsole.log(response.data);\n        return response.data.token; // The token\n    }\n}\n\nexport default App;\n","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport default function register() {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Lets check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://goo.gl/SC7cgQ'\n          );\n        });\n      } else {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              console.log('New content is available; please refresh.');\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport registerServiceWorker from './registerServiceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\nregisterServiceWorker();\n"],"sourceRoot":""}